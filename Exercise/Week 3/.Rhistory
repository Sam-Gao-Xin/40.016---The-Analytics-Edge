pr.wine$sdev
#library(factoextra)
fviz_pca_biplot(pr.wine, label = "var", habillage=wine.cl)
fviz_pca_biplot(pr.wine, label = "var", habillage=wine.cl,addEllipses=TRUE, ellipse.level=0.95)
summary(pr.wine)
#library(factoextra)
fviz_pca_biplot(pr.wine, label = "var", habillage=wine.cl)
fviz_pca_biplot(pr.wine, label = "var", habillage=wine.cl,addEllipses=TRUE, ellipse.level=0.95)
str(wineitaly)
str(pr.wine)
head(pr.wine)
pr.wine$rotation[order(pr.wine$rotation[,1],decreasing=T),1:2] ## order according to PC1
pr.wine$rotation[order(pr.wine$rotation[,2],decreasing=T),1:2] ## order according to PC2
pr.wine$rotation[order(pr.wine$rotation[,1],decreasing=T),1:2] ## order according to PC1
pr.wine$rotation[order(pr.wine$rotation[,2],decreasing=T),1:2] ## order according to PC2
pve.w<- pr.wine$sdev^2/sum(pr.wine$sdev^2)
cpve.w<- cumsum(pve.w)
pve.w
cpve.w
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(pr.wine,type="l",ylim=c(0,5),main="Scree plot")+abline(h=1,col="red")
pve.w<- pr.wine$sdev^2/sum(pr.wine$sdev^2)
pve.w
cpve.w<- cumsum(pve.w)
cpve.w
pve.w
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(pr.wine,type="l",ylim=c(0,5),main="Scree plot")+abline(h=1,col="red")
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(pr.wine,type="l",ylim=c(0,5),main="Scree plot")+abline(h=1,col="red")
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
pr.out.sc
pr.out
head(pr.out)
summary(pr.out)
head(pr.out)
pr.out
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(pr.wine,type="l",ylim=c(0,5),main="Scree plot")+abline(h=1,col="red")
n
plot(cpve.w,xlab="Principal components",type="l",ylim=c(0,1))+abline(h=0.8,col="red")+abline(v=5,col="blue")
plot(pr.wine,type="l",ylim=c(0,5),main="Scree plot")+abline(h=1,col="red")
setwd("/Users/james/OneDrive - Singapore University of Technology and Design/SUTD/Year 3/Term 6/40.016 - The Analytics Edge/Exercise/Week 3")
baseballlarge <- read.csv("baseballlarge(5).csv")
str(baseballlarge)
# number of observations equal to number of rows
nrow(baseballlarge)
# number of entries can be counted with length()
length(table(baseballlarge$Year))
names(table(baseballlarge$Year))
(table(baseballlarge$Year))
names(table(baseballlarge$Year))(table(baseballlarge$Year))
names
YEARS_IN_DATASET <- as.numeric(names(table(baseballlarge$Year)))
names(table(baseballlarge$Year))
YEARS_IN_DATASET <- as.numeric(names(table(baseballlarge$Year)))
NUM_YEARS <- length(YEARS_IN_DATASET)
START_YEAR <- min(YEARS_IN_DATASET)
END_YEAR <- max(YEARS_IN_DATASET)
MISSING_YEARS <- setdiff(START_YEAR:END_YEAR, YEARS_IN_DATASET) #find which are the missing years
NUM_YEARS
START_YEAR
END_YEAR
MISSING_YEARS
S <- cards()
A <- subset(S, suit == "Heart")
B <- subset(S, rank == "A" )
setdiff(B, A)
x = "sdfsdf"
y= "we wge"
setdiff(x, y)
y ="sdfsde"
setdiff(x,y)
START_YEAR:END_YEAR
YEARS_IN_DATASET
# number of entries can be counted with length()
length(table(baseballlarge$Year))
table(baseballlarge$Year)
# number of entries can be counted with length()
length(table(baseballlarge$Year))
length(names(table(baseballlarge$Year)))
table(table(baseballlarge$Year))
year_col <- baseballlarge$Year
year_col
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
unname(table(baseballlarge$NumCompetitors)["8"]) # with unname(), we can retrieve 128 directly
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
A:
```{r 1_b1}
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
```
To retrieve the number directly:
```{r 1_b2}
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
unname(table(baseballlarge$NumCompetitors)["8"]) # with unname(), we can retrieve 128 directly
```
There were 128 team/year pairs where 8 teams were invited to the playoffs. (Note that we can also verify this with [iv.](#oneaiv) as 8 * 16 = 128)
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
unname(table(baseballlarge$NumCompetitors)["8"]) # with unname(), we can retrieve 128 directly
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
table(year_col)[as.character(year_col)]
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
year_col
[as.character(year_col)]
as.character(year_col)
table(year_col)[as.character(year_col)]
table(year_col)[2]
table(year_col)
table(year_col)
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
setwd("/Users/james/OneDrive - Singapore University of Technology and Design/SUTD/Year 3/Term 6/40.016 - The Analytics Edge/Exercise/Week 3")
baseballlarge <- read.csv("baseballlarge(5).csv")
str(baseballlarge)
rm(list=ls())
setwd("/Users/james/OneDrive - Singapore University of Technology and Design/SUTD/Year 3/Term 6/40.016 - The Analytics Edge/Exercise/Week 3")
baseballlarge <- read.csv("baseballlarge(5).csv")
str(baseballlarge)
# number of observations equal to number of rows
nrow(baseballlarge)
# number of entries can be counted with length()
length(table(baseballlarge$Year))
names(table(baseballlarge$Year))
YEARS_IN_DATASET <- as.numeric(names(table(baseballlarge$Year)))
NUM_YEARS <- length(YEARS_IN_DATASET)
START_YEAR <- min(YEARS_IN_DATASET)
END_YEAR <- max(YEARS_IN_DATASET)
MISSING_YEARS <- setdiff(START_YEAR:END_YEAR, YEARS_IN_DATASET) #find which are the missing years
NUM_YEARS
START_YEAR
END_YEAR
MISSING_YEARS
baseballlarge <- subset(baseballlarge, Playoffs == 1)
nrow(baseballlarge)
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
table(year_col)
year_col
table(year_col)
table(year_col)[2]
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(year_col)[2]
table(year_col)["2"]
as.character(year_col)
table(year_col)["2012"]
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
baseballlarge$NumCompetitors
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)
[as.character(year_col)]
[as.character(year_col)]
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
year_col <- baseballlarge$Year
#the column of Year values, given by as.character(year_col), are taken and mapped to values as found in table(year_col). They are then assigned to a new column NumCompetitors
baseballlarge$NumCompetitors <- table(year_col)[as.character(year_col)]
table(baseballlarge$NumCompetitors)
table(year_col)
baseballlarge
table(year_col)
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
unname(table(baseballlarge$NumCompetitors)["8"]) # with unname(), we can retrieve 128 directly
table(baseballlarge$NumCompetitors)
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
baseballlarge$NumCompetitors
table(baseballlarge$NumCompetitors)["8"]  #this lets us see the value 8, and count 128
unname(table(baseballlarge$NumCompetitors)["8"]) # with unname(), we can retrieve 128 directly
baseballlarge$WorldSeries <- as.integer(baseballlarge$RankPlayoffs == 1) #as.integer converts TRUE to 1 and FALSE to 0
table(baseballlarge$WorldSeries)
unname(table(baseballlarge$WorldSeries)["0"])
# in this example we will just grab a random element from the summary
x <- summary(model_1_d)  # to make a short-named new variable
x$iter # simply type "x$" and wait for RStudio to suggest things
model_1_d <- glm(WorldSeries ~ Year, data = baseballlarge, family = binomial)
summary(model_1_d)
# in this example we will just grab a random element from the summary
x <- summary(model_1_d)  # to make a short-named new variable
x$iter # simply type "x$" and wait for RStudio to suggest things
# we use [2, 4] as following models will only have 1 variable anyway
# one can get the p-value column using [,4]
# 'coefficients' can be shortened to 'coef' i.e. summary(model1)$coef
# assuming no other elements named 'coef' or similar were added
summary(model_1_d)$coefficients[2, 4]
# initialise some containers we will add to later
p_val_1_d <- c() #to save our p-values for later
model_list_1 <- list()  # to contain all the models later
all_vars_1 <- c("Year", "RS", "RA", "W", "OBP", "SLG", "BA",
"RankSeason", "NumCompetitors", "League")
#to train single-variable models
for (variable in all_vars_1) {
model <- glm(as.formula(paste0("WorldSeries ~ ", variable)),
data = baseballlarge, family = binomial)
model_list_1[[variable]] <- model #save the trained model in the list
# we are appending a named numeric variable, for reference later
p_val_1_d <- c(p_val_1_d,
setNames(summary(model)$coefficients[2, 4], variable))
}
p_val_1_d
sig_vars_1_d <- names(p_val_1_d[p_val_1_d < 0.05])
sig_vars_1_d
p_val_1_d[p_val_1_d < 0.05]
```{r 1_d4}
sig_vars_1_d <- names(p_val_1_d[p_val_1_d < 0.05])
sig_vars_1_d
sig_vars_1_e <- c(sig_vars_1_d, "W", "SLG") # add on manually considered W and SLG
# with this we can make the formula without manually typing all the variable names
# we need 2 paste0() as the sig_vars_1_d  are a vector of characters
# we need to collapse sig_vars_1_e into string "Year + ... + SLG"
formula_1 <- as.formula(paste0("WorldSeries ~ ",
paste0(sig_vars_1_e, collapse = "+")))
model_1_e <- glm(formula_1, data = baseballlarge, family = binomial)
# p-values
p_val_1_e <- summary(model_1_e)$coefficients[,4]
p_val_1_e
names(p_val_1_e[p_val_1_e < 0.05])
corr_1 <- cor(baseballlarge[,sig_vars_1_d])
corr_1
sig_vars_1_d
diag(corr_1) <- 0  # self-correlation not relevant
row.names(which(corr_1 > 0.8, arr.ind = T))
x <- row.names(which(corr_1 > 0.8, arr.ind = T))  # NOT DISPLAYED
x
model_1_g <- glm(WorldSeries ~ Year + RA,
data = baseballlarge, family = binomial)
summary(model_1_g)
summary(model_1_g)$aic  # we can use this to grab AIC directly
var_combns_1 <- combn(sig_vars_1_d, 2)  # combinations of 2 variables
aic_table_1 <- data.frame(var_1 = character(), var_2 = character(),
aic = numeric())
#iterate through the pariwise combinations of variables
for (idx in 1:choose(length(sig_vars_1_d), 2)) {
var_comb <- var_combns_1[,idx] #get the combination of variables
model <- glm(formula(paste0("WorldSeries ~ ", paste0(var_comb, collapse = "+"))),
data = baseballlarge, family = binomial)
# note that rbind is relatively slow but this is not too important
aic_table_1 <- rbind(aic_table_1,
data.frame(var1 = var_comb[1],
var2 = var_comb[2],
aic = summary(model)$aic))
}
#iterate through all the original variables (single variables)
for (model in model_list_1) {
aic_table_1 <- rbind(aic_table_1,
data.frame(var1 = names(model$coefficients)[2],
var2 = NA,  # NULL does not work
aic = model$aic))
}
aic_table_1
aic_table_1
var_combns_1 <- combn(sig_vars_1_d, 2)  # combinations of 2 variables
aic_table_1 <- data.frame(var_1 = character(), var_2 = character(),
aic = numeric())
#iterate through the pariwise combinations of variables
for (idx in 1:choose(length(sig_vars_1_d), 2)) {
var_comb <- var_combns_1[,idx] #get the combination of variables
model <- glm(formula(paste0("WorldSeries ~ ", paste0(var_comb, collapse = "+"))),
data = baseballlarge, family = binomial)
# note that rbind is relatively slow but this is not too important
aic_table_1 <- rbind(aic_table_1,
data.frame(var1 = var_comb[1],
var2 = var_comb[2],
aic = summary(model)$aic))
}
aic_table_1
var_combns_1 <- combn(sig_vars_1_d, 2)  # combinations of 2 variables
aic_table_1 <- data.frame(var_1 = character(), var_2 = character(),
aic = numeric())
#iterate through the pariwise combinations of variables
for (idx in 1:choose(length(sig_vars_1_d), 2)) {
var_comb <- var_combns_1[,idx] #get the combination of variables
model <- glm(formula(paste0("WorldSeries ~ ", paste0(var_comb, collapse = "+"))),
data = baseballlarge, family = binomial)
# note that rbind is relatively slow but this is not too important
aic_table_1 <- rbind(aic_table_1,
data.frame(var1 = var_comb[1],
var2 = var_comb[2],
aic = summary(model)$aic))
}
aic_table_1
#iterate through all the original variables (single variables)
for (model in model_list_1) {
aic_table_1 <- rbind(aic_table_1,
data.frame(var1 = names(model$coefficients)[2],
var2 = NA,  # NULL does not work
aic = model$aic))
}
aic_table_1
aic_table_1[which.min(aic_table_1[,3]),]
#use this to help you clear your environment :)
setdiff(ls(), ls(pattern = "SETUP"))
rm(list = setdiff(ls(), ls(pattern = "SETUP")))
#use this to help you clear your environment :)
setdiff(ls(), ls(pattern = "SETUP"))
rm(list = setdiff(ls(), ls(pattern = "SETUP")))
setwd("~/OneDrive - Singapore University of Technology and Design/SUTD/Year 3/Term 6/40.016 - The Analytics Edge/Exercise/Week 3")
Parole <- read.csv("Parole(1)(5).csv")
str(Parole)
nrow(Parole)
str(Parole)
nrow(Parole)
unname(table(Parole$Violator)[2])  # col of "1" is the second element
unname(table(Parole$Violator)[1])  # col of "1" is the second element
unname(table(Parole$Violator)[0])  # col of "1" is the second element
unname(table(Parole$Violator)[3])  # col of "1" is the second element
unname(table(Parole$Violator)[2])  # col of "1" is the second element
table(Parole$Violator)
unname(table(Parole$Violator)[2])  # col of "1" is the second element
table(Parole$Violator)
unname(table(Parole$Violator)[2])  # col of "1" is the second element
str(Parole)
# We first observe that there are 2 columns with character type, State and Crime
sapply(Parole, class)
# We first observe that there are 2 columns with character type, State and Crime
sapply(Parole, class)
# We first observe that there are 2 columns with character type, State and Crime
sapply(Parole, class)
#Convert them to factors. There's no natural ordering to these factors
Parole$State <- as.factor(Parole$State)
Parole$Crime <- as.factor(Parole$Crime)
sapply(Parole[sapply(Parole, is.factor)], nlevels) #get the number of levels of each column
# We first observe that there are 2 columns with character type, State and Crime
sapply(Parole, class)
sapply(Parole[sapply(Parole, is.factor)], nlevels) #get the number of levels of each column
Parole[sapply(Parole, is.factor)]
sapply(Parole[sapply(Parole, is.factor)], nlevels) #get the number of levels of each column
set.seed(144)
library(caTools)
s1 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr1 <- subset(Parole, s1 == TRUE)
te1 <- subset(Parole, s1 == FALSE)
set.seed(144)
library(caTools)
s1 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr1 <- subset(Parole, s1 == TRUE)
te1 <- subset(Parole, s1 == FALSE)
All of this can be verified fairly easily, although we will use different variable names:
```{r 2_d1}
set.seed(144)
library(caTools)
s1 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr1 <- subset(Parole, s1 == TRUE)
te1 <- subset(Parole, s1 == FALSE)
```
The second split,
```{r 2_d2}
set.seed(144)
library(caTools)
s2 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr2 <- subset(Parole, s2 == TRUE)
te2 <- subset(Parole, s2 == FALSE)
```
Now we compare them:
```{r 2_d3, results = "hold"}
identical(s1, s2, FALSE, FALSE, FALSE, FALSE)
identical(tr1, tr2, FALSE, FALSE, FALSE, FALSE)
identical(te1, te2, FALSE, FALSE, FALSE, FALSE)
```
If anything but three `TRUE`s were returned, then something would have been wrong. One may opt to check with some memory-checking functions that the objects above being checked for being the same are actually residing in different parts of the computer's memory.^[See https://stackoverflow.com/a/10913296] (Else if they were the same object in memory, it would make sense they would pass checks of being identical.) Further, running `library(caTools)` is not required other than the first time, and should not affect the splits.
Next we just check without setting the seed:
```{r 2_d4}
s3 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr3 <- subset(Parole, s3 == TRUE)
te3 <- subset(Parole, s3 == FALSE)
identical(s1, s3, FALSE, FALSE, FALSE, FALSE)
```
set.seed(144)
library(caTools)
s2 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr2 <- subset(Parole, s2 == TRUE)
te2 <- subset(Parole, s2 == FALSE)
set.seed(144)
library(caTools)
s2 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr2 <- subset(Parole, s2 == TRUE)
te2 <- subset(Parole, s2 == FALSE)
All of this can be verified fairly easily, although we will use different variable names:
```{r 2_d1}
set.seed(144)
library(caTools)
s1 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr1 <- subset(Parole, s1 == TRUE)
te1 <- subset(Parole, s1 == FALSE)
```
The second split,
```{r 2_d2}
set.seed(144)
library(caTools)
s2 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr2 <- subset(Parole, s2 == TRUE)
te2 <- subset(Parole, s2 == FALSE)
```
Now we compare them:
```{r 2_d3, results = "hold"}
identical(s1, s2, FALSE, FALSE, FALSE, FALSE)
identical(tr1, tr2, FALSE, FALSE, FALSE, FALSE)
identical(te1, te2, FALSE, FALSE, FALSE, FALSE)
```
If anything but three `TRUE`s were returned, then something would have been wrong. One may opt to check with some memory-checking functions that the objects above being checked for being the same are actually residing in different parts of the computer's memory.^[See https://stackoverflow.com/a/10913296] (Else if they were the same object in memory, it would make sense they would pass checks of being identical.) Further, running `library(caTools)` is not required other than the first time, and should not affect the splits.
Next we just check without setting the seed:
```{r 2_d4}
s3 <- sample.split(Parole$Violator, SplitRatio = 0.7)
tr3 <- subset(Parole, s3 == TRUE)
te3 <- subset(Parole, s3 == FALSE)
identical(s1, s3, FALSE, FALSE, FALSE, FALSE)
```
identical(s1, s2, FALSE, FALSE, FALSE, FALSE)
identical(tr1, tr2, FALSE, FALSE, FALSE, FALSE)
identical(te1, te2, FALSE, FALSE, FALSE, FALSE)
set.seed(144)
library(caTools)  # not required by this point
split <- sample.split(Parole$Violator, SplitRatio = 0.7)
train <- subset(Parole, split == TRUE)
test <- subset(Parole, split == FALSE)
train
split <- sample.split(Parole$Violator, SplitRatio = 0.7)
trian
train
train <- subset(Parole, split == TRUE)
test <- subset(Parole, split == FALSE)
train
model_2 <- glm(Violator ~ ., data = train, family = binomial)
summary(model_2)
coef_table_2 <- summary(model_2)$coefficients #save the coefficients for later use
p_val_2_e <- coef_table_2[,4]
sig_vars_2 <- names(p_val_2_e[p_val_2_e <= 0.05])
sig_vars_2
# The variable name 'row_2' is with respect to this document's question numbers
# NOT the second row
row_2 <- coef_table_2[rownames(coef_table_2) == "MultipleOffenses"]
names(row_2) <- colnames(coef_table_2)
row_2[1]  # coefficient (amount of increase in log odds if one comitted multiple offenses)
exp(row_2[1])  # odds
# The variable name 'row_2' is with respect to this document's question numbers
# NOT the second row
row_2 <- coef_table_2[rownames(coef_table_2) == "MultipleOffenses"]
# The variable name 'row_2' is with respect to this document's question numbers
# NOT the second row
row_2 <- coef_table_2[rownames(coef_table_2) == "MultipleOffenses"]
names(row_2) <- colnames(coef_table_2)
row_2[1]  # coefficient (amount of increase in log odds if one comitted multiple offenses)
exp(row_2[1])  # odds
# Here we prep the coefficients we need
coef_2 <- coef_table_2 #includes many coefficients we don't need
# We want to remove the coefficients for StateLouisiana, StateOther, StateVirginia, CrimeDrugs, CrimeOther
coef_2 <- coef_2[!(startsWith(rownames(coef_2), "State")  |
startsWith(rownames(coef_2), "Crime")) |
rownames(coef_2) == "CrimeLarceny",]
# Note that we retain CrimeLarceny because our prisoner has that
# Also note that StateKentucky is being used as a reference
# and hence there is no coefficient
```{r 2_g2}
x_2 <- c(1,  # intercept
1,  # male
1,  # white
50, # age
3,  # time served
12, # max sentence
0,  # multiple offenses
1)  # larceny
logodds_2 <- coef_2[,1] %*% x_2  # matrix mult
#logodds_2
#exp(logodds_2)
prob = exp(logodds_2)/ (1+exp(logodds_2))
prob
# Here we prep the coefficients we need
coef_2 <- coef_table_2 #includes many coefficients we don't need
# We want to remove the coefficients for StateLouisiana, StateOther, StateVirginia, CrimeDrugs, CrimeOther
coef_2 <- coef_2[!(startsWith(rownames(coef_2), "State")  |
startsWith(rownames(coef_2), "Crime")) |
rownames(coef_2) == "CrimeLarceny",]
x_2 <- c(1,  # intercept
1,  # male
1,  # white
50, # age
3,  # time served
12, # max sentence
0,  # multiple offenses
1)  # larceny
logodds_2 <- coef_2[,1] %*% x_2  # matrix mult
# Here we prep the coefficients we need
coef_2 <- coef_table_2 #includes many coefficients we don't need
coef_2
coef_2[,1]
